/*
 * ramn_trng.c
  ******************************************************************************
  * @attention
  *
  * <h2><center>&copy; Copyright (c) 2021 TOYOTA MOTOR CORPORATION.
  * ALL RIGHTS RESERVED.</center></h2>
  *
  * This software component is licensed by TOYOTA MOTOR CORPORATION under BSD 3-Clause license,
  * the "License"; You may not use this file except in compliance with the
  * License. You may obtain a copy of the License at:
  *                        opensource.org/licenses/BSD-3-Clause
  *
  ******************************************************************************
 */

#include "ramn_trng.h"

//RNG HAL Handle
static RNG_HandleTypeDef* pHrng;

//Stream buffer automatically updated with random bytes
static StreamBufferHandle_t RandomStreamBufferHandle;

////Semaphore to enable access to TRNG module from different threads
static SemaphoreHandle_t TRNG_SEMAPHORE;
static StaticSemaphore_t TRNG_SEMAPHORE_STRUCT;
static StaticStreamBuffer_t TRNG_POOL_STRUCT;

//Static buffer that holds data from the stream buffer
static uint8_t TRNG_POOL[TRNG_POOL_SIZE];


//Request module to refill the stream buffer from the TRNG peripheral
static void RNG_Refill(void)
{
	if (xStreamBufferBytesAvailable(RandomStreamBufferHandle) <= RNG_REFILL_THRESHOLD)
	{
		while (HAL_RNG_GenerateRandomNumber_IT(pHrng) != HAL_OK);
	}
}

// Exported features -----------------------------



void RAMN_RNG_Init(RNG_HandleTypeDef* handle)
{
	pHrng = handle;
	RandomStreamBufferHandle    = xStreamBufferCreateStatic(TRNG_POOL_SIZE,sizeof(uint8_t),TRNG_POOL,&TRNG_POOL_STRUCT);
	TRNG_SEMAPHORE   = xSemaphoreCreateMutexStatic(&TRNG_SEMAPHORE_STRUCT);
}

//Note; the "hrng" POINTER here has the same name as the "hrng" STRUCTURE defined in the global section.
//Although confusing, both are automatically generated by STM32CubeIDE and cannot easily be changed.
void HAL_RNG_ReadyDataCallback(RNG_HandleTypeDef *hrng, uint32_t random32bit)
{
	//Note that we may push more data than space is available.
	//We do not check as we do not mind losing random bytes.
	xStreamBufferSend(RandomStreamBufferHandle, (void *)&random32bit, sizeof(uint32_t),0U);
	if(xStreamBufferSpacesAvailable(RandomStreamBufferHandle) != 0)
	{
		HAL_RNG_GenerateRandomNumber_IT(hrng);
	}
}

void HAL_RNG_ErrorCallback(RNG_HandleTypeDef *hrng)
{
	//TODO: handle RNG errors
	uint32_t err = HAL_RNG_GetError(hrng);
	/*
	if (err & HAL_RNG_ERROR_INVALID_CALLBACK)
	{
		//Invalid callbacks registered
	}*/
	if (err & HAL_RNG_ERROR_TIMEOUT)
	{
		//Timeout error
	}
	if (err & HAL_RNG_ERROR_BUSY)
	{
		//Busy Error
	}
	if (err & HAL_RNG_ERROR_SEED)
	{
		//Seed Error
	}
	if (err & HAL_RNG_ERROR_CLOCK)
	{
		//Clock Error
	}
}

uint8_t RAMN_RNG_Pop8(void)
{
	uint8_t result;
	RNG_Refill(); //Refill the RNG if necessary
	while (xSemaphoreTake(TRNG_SEMAPHORE, portMAX_DELAY ) != pdTRUE);
	xStreamBufferReceive(RandomStreamBufferHandle,(void *)&result,sizeof(result),portMAX_DELAY);
	xSemaphoreGive(TRNG_SEMAPHORE);
	return result;
}

uint16_t RAMN_RNG_Pop16(void)
{
	uint16_t result;
	RNG_Refill(); //Refill the RNG if necessary
	while (xSemaphoreTake(TRNG_SEMAPHORE, portMAX_DELAY ) != pdTRUE);
	xStreamBufferReceive(RandomStreamBufferHandle,(void *)&result,sizeof(result),portMAX_DELAY);
	xSemaphoreGive(TRNG_SEMAPHORE);
	return result;
}

uint32_t RAMN_RNG_Pop32(void)
{
	uint32_t result;
	RNG_Refill(); //Refill the RNG if necessary
	while (xSemaphoreTake(TRNG_SEMAPHORE, portMAX_DELAY ) != pdTRUE);
	xStreamBufferReceive(RandomStreamBufferHandle,(void *)&result,sizeof(result),portMAX_DELAY);
	xSemaphoreGive(TRNG_SEMAPHORE);
	return result;
}
