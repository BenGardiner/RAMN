name: build all, clean release and debug

on:
  push:
    branches: [main]
  pull_request:

jobs:
  build_all:
    strategy:
      fail-fast: false
      matrix:
        spice: [RAMNV1]
        conf: [Release, Debug]

    runs-on: ubuntu-latest
    steps:
      - name: checkout
        uses: actions/checkout@v4

      - name: Build ECUB
        uses: xanderhendriks/action-build-stm32cubeide@v7.0
        with:
          project-path: firmware/${{ matrix.spice }} -D TARGET_ECUB
          project-target: ${{ matrix.spice}}/${{ matrix.conf}} -D TARGET_ECUB
      - name: Copy ECUB hex
        run: cp firmware/${{ matrix.spice }}/${{ matrix.conf }}/${{ matrix.spice }}.hex scripts/firmware/ECUB.hex

      - name: Build ECUC
        uses: xanderhendriks/action-build-stm32cubeide@v7.0
        with:
          project-path: firmware/${{ matrix.spice }} -D TARGET_ECUC
          project-target: ${{ matrix.spice}}/${{ matrix.conf}} -D TARGET_ECUC
      - name: Copy ECUC hex
        run: cp firmware/${{ matrix.spice }}/${{ matrix.conf }}/${{ matrix.spice }}.hex scripts/firmware/ECUC.hex

      - name: Build ECUD
        uses: xanderhendriks/action-build-stm32cubeide@v7.0
        with:
          project-path: firmware/${{ matrix.spice }} -D TARGET_ECUD
          project-target: ${{ matrix.spice}}/${{ matrix.conf}} -D TARGET_ECUD
      - name: Copy ECUD hex
        run: cp firmware/${{ matrix.spice }}/${{ matrix.conf }}/${{ matrix.spice }}.hex scripts/firmware/ECUD.hex

      - name: Build ECUA
        if: ${{ matrix.spice!='RAMNV1_CTF' }}
        uses: xanderhendriks/action-build-stm32cubeide@v7.0
        with:
          project-path: firmware/${{ matrix.spice }} -D TARGET_ECUA
          project-target: ${{ matrix.spice}}/${{ matrix.conf}} -D TARGET_ECUA
      - name: Copy ECUA hex
        if: ${{ matrix.spice!='RAMNV1_CTF' }}
        run: cp firmware/${{ matrix.spice }}/${{ matrix.conf }}/${{ matrix.spice }}.hex scripts/firmware/ECUA.hex

      - name: Collect hex file sizes
        if: always()
        run: |
          mkdir -p build-metrics
          for ecu in ECUA ECUB ECUC ECUD; do
            hex="scripts/firmware/${ecu}.hex"
            if [ -f "$hex" ]; then
              echo "${ecu}=$(wc -c < "$hex" | tr -d ' ')" >> build-metrics/hex-sizes.txt
            else
              echo "${ecu}=N/A" >> build-metrics/hex-sizes.txt
            fi
          done

      - name: Upload build metrics
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: build-metrics-${{ matrix.spice }}-${{ matrix.conf }}
          path: build-metrics/

      - name: upload RAMN dir as artifact
        if: ${{ !env.ACT }}
        uses: actions/upload-artifact@v4
        with:
          name: ${{ matrix.spice }}-${{ matrix.conf}}
          path: .

  macro_coverage:
    permissions:
      contents: read
    strategy:
      fail-fast: false
      matrix:
        include:
          # Test GSUSB interface instead of CDC on ECUA
          - ecu: TARGET_ECUA
            variant: gsusb
            enable: "ENABLE_GSUSB"
            disable: "ENABLE_CDC"
          # Test ECUA without UDS diagnostics
          - ecu: TARGET_ECUA
            variant: no_uds
            enable: ""
            disable: "ENABLE_UDS ENABLE_UDS_REPROGRAMMING"
          # Test ECUA without screen, chip8, spi, j1979, minictf
          - ecu: TARGET_ECUA
            variant: no_extras
            enable: ""
            disable: "ENABLE_J1979 ENABLE_MINICTF ENABLE_CHIP8 ENABLE_SCREEN ENABLE_SPI"
          # Test ECUA without debug and stats features
          - ecu: TARGET_ECUA
            variant: no_debug
            enable: ""
            disable: "ENABLE_USB_DEBUG ENABLE_JOYSTICK_CONTROLS GENERATE_RUNTIME_STATS"
          # Test KWP protocol on ECUB
          - ecu: TARGET_ECUB
            variant: kwp
            enable: "ENABLE_KWP"
            disable: ""
          # Test ECUB without dynamic bitrate
          - ecu: TARGET_ECUB
            variant: no_dynamic_bitrate
            enable: ""
            disable: "ENABLE_DYNAMIC_BITRATE"
          # Test watchdog on ECUB
          - ecu: TARGET_ECUB
            variant: watchdog
            enable: "WATCHDOG_ENABLE"
            disable: ""
          # Test UART on ECUC (no CDC conflict)
          - ecu: TARGET_ECUC
            variant: uart
            enable: "ENABLE_UART"
            disable: ""

    runs-on: ubuntu-latest
    steps:
      - name: checkout
        uses: actions/checkout@v4

      - name: Modify ramn_config.h
        run: |
          CONFIG=firmware/RAMNV1/Core/Inc/ramn_config.h
          echo "## Macro Coverage Build: \`${{ matrix.ecu }}\` / \`${{ matrix.variant }}\`" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "| Action | Macro |" >> $GITHUB_STEP_SUMMARY
          echo "|--------|-------|" >> $GITHUB_STEP_SUMMARY

          # Comment out #define lines: matches "#define MACRO" with word boundary
          # to avoid partial matches (e.g. ENABLE_UDS won't match ENABLE_UDS_REPROGRAMMING).
          # Uses [^A-Za-z0-9_] or end-of-line as word boundary after the macro name.
          for macro in ${{ matrix.disable }}; do
            sed -i "s~^\([[:space:]]*\)#define ${macro}\([^A-Za-z0-9_]\|$\)~\1//#define ${macro}\2~" "$CONFIG"
            echo "| Disabled | \`${macro}\` |" >> $GITHUB_STEP_SUMMARY
          done

          # Uncomment //#define lines: handles both "//#define" and "// #define" formats
          # (zero or more spaces between // and #define) with the same word boundary logic.
          for macro in ${{ matrix.enable }}; do
            sed -i "s~^\([[:space:]]*\)//[[:space:]]*#define ${macro}\([^A-Za-z0-9_]\|$\)~\1#define ${macro}\2~" "$CONFIG"
            echo "| Enabled | \`${macro}\` |" >> $GITHUB_STEP_SUMMARY
          done

          echo "" >> $GITHUB_STEP_SUMMARY

      - name: Build ${{ matrix.ecu }}
        id: build
        continue-on-error: true
        uses: xanderhendriks/action-build-stm32cubeide@v7.0
        with:
          project-path: firmware/RAMNV1 -D ${{ matrix.ecu }}
          project-target: RAMNV1/Release -D ${{ matrix.ecu }}

      - name: Collect build results
        if: always()
        run: |
          mkdir -p macro-results
          {
            echo "ecu=${{ matrix.ecu }}"
            echo "variant=${{ matrix.variant }}"
            echo "enable=${{ matrix.enable }}"
            echo "disable=${{ matrix.disable }}"
            echo "outcome=${{ steps.build.outcome }}"
            hex="firmware/RAMNV1/Release/RAMNV1.hex"
            if [ -f "$hex" ]; then
              echo "hex_size=$(wc -c < "$hex" | tr -d ' ')"
            else
              echo "hex_size=N/A"
            fi
            # Search for warning count in any build log files
            warn_count=0
            found_logs=false
            while IFS= read -r -d '' logfile; do
              found_logs=true
              w=$(grep -ci "warning:" "$logfile" 2>/dev/null || echo 0)
              warn_count=$((warn_count + w))
            done < <(find firmware/RAMNV1 -name "*.log" -print0 2>/dev/null)
            if [ "$found_logs" = "true" ]; then
              echo "warnings=${warn_count}"
            else
              echo "warnings=N/A"
            fi
          } > macro-results/result.txt

      - name: Upload macro results
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: macro-results-${{ matrix.ecu }}-${{ matrix.variant }}
          path: macro-results/

      - name: Report build result
        if: always()
        run: |
          if [ "${{ steps.build.outcome }}" = "success" ]; then
            echo "### âœ… Build PASSED" >> $GITHUB_STEP_SUMMARY
          else
            echo "### âŒ Build FAILED" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "**Failed configuration details:**" >> $GITHUB_STEP_SUMMARY
            echo "- **ECU:** \`${{ matrix.ecu }}\`" >> $GITHUB_STEP_SUMMARY
            echo "- **Variant:** \`${{ matrix.variant }}\`" >> $GITHUB_STEP_SUMMARY
            if [ -n "${{ matrix.enable }}" ]; then
              echo "- **Macros enabled:** \`${{ matrix.enable }}\`" >> $GITHUB_STEP_SUMMARY
            fi
            if [ -n "${{ matrix.disable }}" ]; then
              echo "- **Macros disabled:** \`${{ matrix.disable }}\`" >> $GITHUB_STEP_SUMMARY
            fi
          fi

  coverage_report:
    permissions:
      contents: read
      pull-requests: write
    needs: [build_all, macro_coverage]
    if: always()
    runs-on: ubuntu-latest
    steps:
      - name: checkout
        uses: actions/checkout@v4

      - name: Download build metrics
        continue-on-error: true
        uses: actions/download-artifact@v4
        with:
          pattern: build-metrics-*
          path: all-build-metrics

      - name: Download macro results
        continue-on-error: true
        uses: actions/download-artifact@v4
        with:
          pattern: macro-results-*
          path: all-macro-results

      - name: Calculate .c line coverage
        id: line_coverage
        run: |
          python3 << 'COVERAGE_TOOL' > coverage_output.txt
          import re, glob, sys, os

          def parse_config(path):
              with open(path) as f:
                  lines = f.readlines()
              targets = {t: set() for t in
                         ["TARGET_ECUA","TARGET_ECUB","TARGET_ECUC","TARGET_ECUD"]}
              common = set()
              cur = None; depth = 0; tdepth = 0; guard_depth = 0
              for line in lines:
                  s = line.strip()
                  if re.match(r'#\s*(?:ifdef|ifndef|if)\b', s):
                      depth += 1
                      if depth == 1 and re.match(r'#\s*ifndef\s+INC_', s):
                          guard_depth = 1
                      elif cur is None:
                          for t in targets:
                              if t in s and 'defined' in s and '!' not in s:
                                  cur = t; tdepth = depth; break
                  elif s.startswith('#endif'):
                      if cur and depth == tdepth: cur = None
                      depth = max(depth - 1, 0)
                  m = re.match(r'#\s*define\s+(\w+)', s)
                  if m:
                      macro = m.group(1)
                      if macro.startswith('INC_'): continue
                      if cur: targets[cur].add(macro)
                      elif depth == guard_depth: common.add(macro)
              configs = {}
              for t in targets:
                  d = targets[t] | common | {t}
                  if d & {"ENABLE_UDS","ENABLE_KWP","ENABLE_XCP"}:
                      d |= {"ENABLE_DIAG","ENABLE_EEPROM_EMULATION"}
                  if d & {"ENABLE_UDS","ENABLE_KWP"}: d.add("ENABLE_ISOTP")
                  if t != "TARGET_ECUA": d.add("USE_HARDWARE_CAN_FILTERS")
                  configs[t] = d
              return configs

          def derive(macros):
              d = set(macros)
              d -= {"ENABLE_DIAG","ENABLE_EEPROM_EMULATION","ENABLE_ISOTP"}
              if d & {"ENABLE_UDS","ENABLE_KWP","ENABLE_XCP"}:
                  d |= {"ENABLE_DIAG","ENABLE_EEPROM_EMULATION"}
              if d & {"ENABLE_UDS","ENABLE_KWP"}: d.add("ENABLE_ISOTP")
              return d

          def eval_cond(expr, defs):
              e = re.sub(r'defined\s*\(\s*(\w+)\s*\)',
                         lambda m: '1' if m.group(1) in defs else '0', expr)
              e = re.sub(r'defined\s+(\w+)',
                         lambda m: '1' if m.group(1) in defs else '0', e)
              e = e.replace('||',' or ').replace('&&',' and ')
              e = re.sub(r'!\s*\(', 'not (', e)
              e = re.sub(r'!(?!=)\s*([01])',
                         lambda m: '1' if m.group(1)=='0' else '0', e)
              try: return bool(eval(e))
              except Exception: return True

          def coverage(files, all_configs):
              total = 0; compiled = set()
              for fp in files:
                  with open(fp) as f: flines = f.readlines()
                  total += len(flines)
                  for defs in all_configs:
                      st = [(True, True, True)]
                      for i, line in enumerate(flines, 1):
                          s = line.strip()
                          if re.match(r'#\s*ifdef\s', s):
                              p = st[-1][0] and st[-1][1]
                              macro = s.split()[1] if len(s.split())>1 else ''
                              a = macro in defs
                              st.append((p, p and a, a))
                          elif re.match(r'#\s*ifndef\s', s):
                              p = st[-1][0] and st[-1][1]
                              macro = s.split()[1] if len(s.split())>1 else ''
                              a = macro not in defs
                              st.append((p, p and a, a))
                          elif re.match(r'#\s*if\s', s) and not re.match(r'#\s*if(n?)def\s', s):
                              p = st[-1][0] and st[-1][1]
                              expr = re.sub(r'^#\s*if\s+', '', s)
                              a = eval_cond(expr, defs) if p else False
                              st.append((p, p and a, a))
                          elif re.match(r'#\s*elif\s', s):
                              if len(st) > 1:
                                  p, _, taken = st.pop()
                                  a = eval_cond(re.sub(r'^#\s*elif\s+','',s), defs) if not taken and p else False
                                  st.append((p, p and a, taken or a))
                          elif re.match(r'#\s*else\b', s):
                              if len(st) > 1:
                                  p, _, taken = st.pop()
                                  st.append((p, p and not taken, True))
                          elif re.match(r'#\s*endif\b', s):
                              if len(st) > 1: st.pop()
                          else:
                              if st[-1][0] and st[-1][1]: compiled.add((fp, i))
              return total, compiled

          base = parse_config('firmware/RAMNV1/Core/Inc/ramn_config.h')
          all_configs = list(base.values())
          variants = [
              ("TARGET_ECUA", {"ENABLE_GSUSB"}, {"ENABLE_CDC"}),
              ("TARGET_ECUA", set(), {"ENABLE_UDS","ENABLE_UDS_REPROGRAMMING"}),
              ("TARGET_ECUA", set(), {"ENABLE_J1979","ENABLE_MINICTF","ENABLE_CHIP8","ENABLE_SCREEN","ENABLE_SPI"}),
              ("TARGET_ECUA", set(), {"ENABLE_USB_DEBUG","ENABLE_JOYSTICK_CONTROLS","GENERATE_RUNTIME_STATS"}),
              ("TARGET_ECUB", {"ENABLE_KWP"}, set()),
              ("TARGET_ECUB", set(), {"ENABLE_DYNAMIC_BITRATE"}),
              ("TARGET_ECUB", {"WATCHDOG_ENABLE"}, set()),
              ("TARGET_ECUC", {"ENABLE_UART"}, set()),
          ]
          for ecu, add, remove in variants:
              all_configs.append(derive((base[ecu] | add) - remove))
          files = sorted(glob.glob(os.path.join('firmware/RAMNV1/Core/Src', '*.c')))
          total, compiled = coverage(files, all_configs)
          pct = len(compiled) * 100 // total if total > 0 else 0
          print(f"total_lines={total}")
          print(f"compiled_lines={len(compiled)}")
          print(f"coverage_pct={pct}")
          COVERAGE_TOOL

          # Export results as step outputs
          cat coverage_output.txt
          while IFS='=' read -r key value; do
            echo "${key}=${value}" >> "$GITHUB_OUTPUT"
          done < coverage_output.txt

      - name: Generate report
        run: |
          total_lines="${{ steps.line_coverage.outputs.total_lines }}"
          compiled_lines="${{ steps.line_coverage.outputs.compiled_lines }}"
          coverage_pct="${{ steps.line_coverage.outputs.coverage_pct }}"

          # --- Build the report ---
          {
            echo "<!-- build-coverage-report -->"
            echo "# ðŸ”¨ Build & Macro Coverage Report"
            echo ""
            echo "## Default Builds â€” Hex File Sizes"
            echo ""
            echo "| ECU | Release | Debug |"
            echo "|-----|---------|-------|"

            # Parse hex sizes from build-metrics artifacts
            declare -A rel dbg
            for ecu in ECUA ECUB ECUC ECUD; do
              rel[$ecu]="N/A"; dbg[$ecu]="N/A"
            done
            for d in all-build-metrics/build-metrics-*/; do
              [ -d "$d" ] || continue
              [ -f "${d}hex-sizes.txt" ] || continue
              conf="${d##*-}"; conf="${conf%/}"
              while IFS='=' read -r ecu size; do
                [ "$conf" = "Release" ] && rel[$ecu]="$size" || dbg[$ecu]="$size"
              done < "${d}hex-sizes.txt"
            done
            for ecu in ECUA ECUB ECUC ECUD; do
              r="${rel[$ecu]}"; d="${dbg[$ecu]}"
              if [ "$r" != "N/A" ] && [ -n "$r" ]; then
                r="$((r / 1024)) KiB ($r bytes)"
              fi
              if [ "$d" != "N/A" ] && [ -n "$d" ]; then
                d="$((d / 1024)) KiB ($d bytes)"
              fi
              echo "| ${ecu} | ${r} | ${d} |"
            done

            echo ""
            echo "## Macro Coverage Build Results"
            echo ""
            echo "| ECU | Variant | Macros Changed | Result | Hex Size | Warnings |"
            echo "|-----|---------|----------------|--------|----------|----------|"

            # Parse results from macro-results artifacts
            for rd in all-macro-results/macro-results-*/; do
              [ -f "${rd}result.txt" ] || continue
              ecu="" variant="" enable="" disable="" outcome="" hex_size="" warnings=""
              while IFS='=' read -r key value; do
                case "$key" in
                  ecu) ecu="$value" ;; variant) variant="$value" ;;
                  enable) enable="$value" ;; disable) disable="$value" ;;
                  outcome) outcome="$value" ;; hex_size) hex_size="$value" ;;
                  warnings) warnings="$value" ;;
                esac
              done < "${rd}result.txt"
              mc=""
              for m in $enable; do mc="${mc}+\`${m}\` "; done
              for m in $disable; do mc="${mc}âˆ’\`${m}\` "; done
              [ "$outcome" = "success" ] && res="âœ… Pass" || res="âŒ Fail"
              if [ "$hex_size" != "N/A" ] && [ -n "$hex_size" ]; then
                hf="$((hex_size / 1024)) KiB"
              else
                hf="N/A"
              fi
              [ "$warnings" = "N/A" ] || [ -z "$warnings" ] && wf="N/A" || wf="$warnings"
              echo "| \`${ecu#TARGET_}\` | ${variant} | ${mc} | ${res} | ${hf} | ${wf} |"
            done

            echo ""
            echo "## Source Code Compile Coverage"
            echo ""
            echo "- **Total .c source lines:** ${total_lines}"
            echo "- **Lines compiled in â‰¥1 configuration:** ${compiled_lines} (~${coverage_pct}%)"
            echo "- **ENABLE_ macro coverage:** 18/21 (85.7%) macros tested in both ON and OFF states"
            echo ""
            echo "<details>"
            echo "<summary>Full ENABLE_ Macro Coverage Table</summary>"
            echo ""
            echo "| # | Macro | Tested ON | Tested OFF | Covered |"
            echo "|---|-------|-----------|------------|---------|"
            echo "| 1 | \`ENABLE_ADC\` | default (ECUB, ECUC, ECUD) | default (ECUA) | âœ… |"
            echo "| 2 | \`ENABLE_USB\` | default (ECUA) | â€” | â¬œ |"
            echo "| 3 | \`ENABLE_CDC\` | default (ECUA) | variant: gsusb (ECUA) | âœ… |"
            echo "| 4 | \`ENABLE_GSUSB\` | variant: gsusb (ECUA) | default (all) | âœ… |"
            echo "| 5 | \`ENABLE_SPI\` | default (ECUA, ECUD) | default (ECUB, ECUC) | âœ… |"
            echo "| 6 | \`ENABLE_SCREEN\` | default (ECUA) | default (ECUB, ECUC, ECUD) | âœ… |"
            echo "| 7 | \`ENABLE_CHIP8\` | default (ECUA) | default (ECUB, ECUC, ECUD) | âœ… |"
            echo "| 8 | \`ENABLE_MINICTF\` | default (ECUA, ECUD) | default (ECUB, ECUC) | âœ… |"
            echo "| 9 | \`ENABLE_UDS_REPROGRAMMING\` | default (all) | variant: no_uds (ECUA) | âœ… |"
            echo "| 10 | \`ENABLE_UDS\` | default (all) | variant: no_uds (ECUA) | âœ… |"
            echo "| 11 | \`ENABLE_J1979\` | default (all) | variant: no_extras (ECUA) | âœ… |"
            echo "| 12 | \`ENABLE_KWP\` | variant: kwp (ECUB) | default (all) | âœ… |"
            echo "| 13 | \`ENABLE_XCP\` | default (ECUB, ECUC, ECUD) | default (ECUA) | âœ… |"
            echo "| 14 | \`ENABLE_JOYSTICK_CONTROLS\` | default (ECUA) | variant: no_debug (ECUA) | âœ… |"
            echo "| 15 | \`ENABLE_USB_DEBUG\` | default (ECUA) | variant: no_debug (ECUA) | âœ… |"
            echo "| 16 | \`ENABLE_USB_AUTODETECT\` | â€” | default (all) | â¬œ |"
            echo "| 17 | \`ENABLE_DYNAMIC_BITRATE\` | default (all) | variant: no_dynamic_bitrate (ECUB) | âœ… |"
            echo "| 18 | \`ENABLE_I2C\` | â€” | default (all) | â¬œ |"
            echo "| 19 | \`ENABLE_UART\` | variant: uart (ECUC) | default (all) | âœ… |"
            echo "| 20 | \`GENERATE_RUNTIME_STATS\` | default (all) | variant: no_debug (ECUA) | âœ… |"
            echo "| 21 | \`WATCHDOG_ENABLE\` | variant: watchdog (ECUB) | default (all) | âœ… |"
            echo ""
            echo "</details>"
          } > report.md

      - name: Post PR comment
        if: github.event_name == 'pull_request'
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            const body = fs.readFileSync('report.md', 'utf8');
            const marker = '<!-- build-coverage-report -->';
            const {data: comments} = await github.rest.issues.listComments({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
            });
            const existing = comments.find(c => c.body.includes(marker));
            if (existing) {
              await github.rest.issues.updateComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                comment_id: existing.id,
                body: body,
              });
            } else {
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.issue.number,
                body: body,
              });
            }

      - name: Write step summary
        if: always()
        run: cat report.md >> $GITHUB_STEP_SUMMARY
